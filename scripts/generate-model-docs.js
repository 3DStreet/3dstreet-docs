/**
 * Generate model documentation pages from 3DStreet catalog.json
 *
 * Usage: node scripts/generate-model-docs.js
 *
 * This script:
 * - Reads catalog.json from the 3dstreet repo
 * - Generates MDX files for each model in docs/models/
 * - Skips files with autoGenerated: false (customized pages)
 * - Creates category index pages
 */

const fs = require('fs');
const path = require('path');

// Configuration
const CATALOG_PATH = path.resolve(__dirname, '../../3dstreet/src/catalog.json');
const OUTPUT_DIR = path.resolve(__dirname, '../docs/models');
const ASSETS_BASE_URL = 'https://assets.3dstreet.app/';

// Category display names
const CATEGORY_LABELS = {
  'vehicles-rigged': 'Vehicles',
  'cyclists': 'Cyclists & Bikes',
  'plants': 'Plants & Trees',
  'dividers': 'Dividers & Barriers',
  'buildings': 'Buildings',
  'fixtures': 'Street Fixtures',
  'signs': 'Signs',
  'other': 'Other'
};

// Category order in sidebar
const CATEGORY_ORDER = [
  'vehicles-rigged',
  'cyclists',
  'buildings',
  'plants',
  'dividers',
  'fixtures',
  'signs',
  'other'
];

function loadCatalog() {
  if (!fs.existsSync(CATALOG_PATH)) {
    console.error(`Catalog not found at: ${CATALOG_PATH}`);
    console.error('Make sure the 3dstreet repo is at ../3dstreet relative to this docs repo');
    process.exit(1);
  }
  return JSON.parse(fs.readFileSync(CATALOG_PATH, 'utf8'));
}

function isAutoGenerated(filePath) {
  if (!fs.existsSync(filePath)) return true; // New file, can generate

  const content = fs.readFileSync(filePath, 'utf8');

  // Check frontmatter for autoGenerated flag
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) return true; // No frontmatter, assume generated

  const frontmatter = frontmatterMatch[1];

  // If autoGenerated: false, don't overwrite
  if (frontmatter.includes('autoGenerated: false')) {
    return false;
  }

  // If autoGenerated: true or not specified, can regenerate
  return true;
}

function formatCategory(category) {
  return CATEGORY_LABELS[category] || category.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

function generateModelPage(model) {
  const imgUrl = model.img ? `${ASSETS_BASE_URL}${model.img}` : null;
  const glbUrl = model.src ? `${ASSETS_BASE_URL}${model.src}` : null;
  const category = model.category || 'other';

  let content = `---
title: "${model.name}"
description: "3D model: ${model.name} for use in 3DStreet scenes"
autoGenerated: true
---

import { ModelViewer } from '@site/src/components/ModelViewer';

# ${model.name}

<ModelViewer
  src="${glbUrl || ''}"
  poster="${imgUrl || ''}"
  alt="${model.name}"
/>

${model.description ? `\n${model.description}\n` : ''}
## Details

| Property | Value |
|----------|-------|
| **ID** | \`${model.id}\` |
| **Category** | [${formatCategory(category)}](../${category}/) |
${glbUrl ? `| **3D Model** | [Download GLB](${glbUrl}) |` : ''}
`;

  if (model.attribution) {
    content += `
## Attribution

${model.attribution}${model.attributionUrl ? ` [Source](${model.attributionUrl})` : ''}
`;
  }

  content += `
## Usage in 3DStreet

Add this model to your scene using the model ID:

\`\`\`
${model.id}
\`\`\`
`;

  return content;
}

function generateCategoryIndex(category, models) {
  const label = formatCategory(category);

  let content = `---
title: "${label}"
description: "Browse ${label.toLowerCase()} 3D models for 3DStreet"
autoGenerated: true
---

# ${label}

Browse all ${models.length} ${label.toLowerCase()} models available in 3DStreet.

| Model | ID |
|-------|-----|
`;

  for (const model of models) {
    const imgUrl = model.img ? `${ASSETS_BASE_URL}${model.img}` : '';
    content += `| [![${model.name}](${imgUrl})](${model.id}) [${model.name}](${model.id}) | \`${model.id}\` |\n`;
  }

  content += `
---

[Back to all models](../)
`;

  return content;
}

function generateMainIndex(modelsByCategory) {
  let content = `---
title: "3D Model Library"
description: "Browse all 3D models available in 3DStreet for street design visualization"
autoGenerated: true
sidebar_position: 1
---

# 3D Model Library

Browse all available 3D models for use in 3DStreet scenes. These models can be added to your street designs to create realistic visualizations.

`;

  for (const category of CATEGORY_ORDER) {
    const models = modelsByCategory[category];
    if (!models || models.length === 0) continue;

    const label = formatCategory(category);
    content += `## [${label}](${category}/)\n\n`;
    content += `${models.length} models available\n\n`;

    // Show first few models as preview
    const preview = models.slice(0, 4);
    content += '| | | | |\n|---|---|---|---|\n|';
    for (const model of preview) {
      const imgUrl = model.img ? `${ASSETS_BASE_URL}${model.img}` : '';
      content += ` [![${model.name}](${imgUrl})](${category}/${model.id}) |`;
    }
    content += '\n\n';
  }

  return content;
}

function main() {
  console.log('Loading catalog...');
  const catalog = loadCatalog();

  // Filter visible models with names
  const visibleModels = catalog.filter(m =>
    m.display !== 'none' &&
    m.name &&
    m.src // Only include models with standalone GLB files for now
  );

  console.log(`Found ${visibleModels.length} models with standalone GLB files`);

  // Group by category
  const modelsByCategory = {};
  for (const model of visibleModels) {
    const category = model.category || 'other';
    if (!modelsByCategory[category]) {
      modelsByCategory[category] = [];
    }
    modelsByCategory[category].push(model);
  }

  // Ensure output directory exists
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });

  // Generate main _category_.json
  const mainCategoryConfig = {
    label: '3D Models',
    position: 10,
    link: {
      type: 'doc',
      id: 'models/index'
    }
  };
  fs.writeFileSync(
    path.join(OUTPUT_DIR, '_category_.json'),
    JSON.stringify(mainCategoryConfig, null, 2)
  );
  console.log('Created docs/models/_category_.json');

  // Generate main index
  const mainIndexPath = path.join(OUTPUT_DIR, 'index.mdx');
  if (isAutoGenerated(mainIndexPath)) {
    fs.writeFileSync(mainIndexPath, generateMainIndex(modelsByCategory));
    console.log('Created docs/models/index.mdx');
  } else {
    console.log('Skipping docs/models/index.mdx (customized)');
  }

  // Generate category folders and pages
  let generatedCount = 0;
  let skippedCount = 0;

  for (const [category, models] of Object.entries(modelsByCategory)) {
    const categoryDir = path.join(OUTPUT_DIR, category);
    fs.mkdirSync(categoryDir, { recursive: true });

    // Category _category_.json
    const position = CATEGORY_ORDER.indexOf(category);
    const categoryCategoryConfig = {
      label: formatCategory(category),
      position: position >= 0 ? position + 1 : 99
    };
    fs.writeFileSync(
      path.join(categoryDir, '_category_.json'),
      JSON.stringify(categoryCategoryConfig, null, 2)
    );

    // Category index page
    const categoryIndexPath = path.join(categoryDir, 'index.mdx');
    if (isAutoGenerated(categoryIndexPath)) {
      fs.writeFileSync(categoryIndexPath, generateCategoryIndex(category, models));
    }

    // Individual model pages
    for (const model of models) {
      const modelPath = path.join(categoryDir, `${model.id}.mdx`);

      if (isAutoGenerated(modelPath)) {
        fs.writeFileSync(modelPath, generateModelPage(model));
        generatedCount++;
      } else {
        skippedCount++;
        console.log(`Skipping ${model.id} (customized)`);
      }
    }

    console.log(`Created docs/models/${category}/ (${models.length} models)`);
  }

  console.log(`\nDone! Generated ${generatedCount} model pages, skipped ${skippedCount} customized pages.`);
}

main();
